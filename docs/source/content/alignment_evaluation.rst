.. raw:: html

    <script type="text/javascript">
        var observer = new MutationObserver(function(mutations) {
            var dark = document.body.dataset.theme == 'dark';

            if (document.body.dataset.theme == 'auto') {
                dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            }
            
            console.log(dark);
            document.getElementsByClassName('header-image')[0].src = dark ? '../_images/jhu-logo-white.png' : "../_images/jhu-logo-dark.png";
            document.getElementsByClassName('sidebar_ccb')[0].src = dark ? '../_images/JHU_ccb-white.png' : "../_images/JHU_ccb-dark.png";
            document.getElementsByClassName('sidebar_wse')[0].src = dark ? '../_images/JHU_wse-white.png' : "../_images/JHU_wse-dark.png";

            console.log("document.getElementsByClassName('sidebar_wse')[0].src: ", document.getElementsByClassName('sidebar_wse')[0].src);
        })
        observer.observe(document.body, {attributes: true, attributeFilter: ['data-theme']});
        console.log(document.body);
    </script>
    <link rel="preload" href="../_images/jhu-logo-dark.png" as="image">



.. raw:: html
    
    <script type="text/javascript">
        var block_to_insert ;
        var container_block ;
        
        block_to_insert = document.createElement( 'div' );
        block_to_insert.innerHTML = '<img alt="My Logo" style="width:80%;  margin:10px; padding-top:30px" class="logo sidebar_ccb align-center" src="../_images/JHU_ccb-dark.png"><img alt="My Logo" class="logo sidebar_wse align-center" style="width:80%;  margin:10px" src="../_images/JHU_wse-dark.png">' ;
        
        container_block = document.getElementsByClassName( 'sidebar-sticky' )[0];
        console.log("container_block: ", container_block);
        container_block.appendChild( block_to_insert );
    </script>


|

.. _alignment-detailed-section:

Alignment file evaluation & cleanup (:code:`BAM`)
=================================================


.. _alignment-introduction:

Introduction
+++++++++++++++++++++++++++++++++++


You are analyzing your RNA-Seq reads using a standard RNA-Seq pipeline. After performing quality control, you have utilized popular spliced aligners such as :code:`HISAT2` and :code:`STAR` to align the reads to the genome. While inspecting the alignments in IGV, you have noticed that some reads are spliced and aligned across different gene loci or intergenic regions. 

.. Here is an example of the EHMT1 gene locus on chromosome 9 visulaized in IGV. This protein-coding gene is located on the forward strand; however, we have observed that the splice aligner generates several splice alignments on the reverse strand. 


This raises concerns regarding the accuracy of these splice alignments and the authenticity of the reads originating from these locations. Additionally, you are curious **if there is a systematic approach to validate these splice alignments**. Unfortunately, there are currently no available tools that can assess the results generated by the aligners. Consequently,

|

**we propose running splam as a new step in standard RNA-Seq analysis pipeline.**

|


The power of splam lies in its ability to filter splice alignments without relying on complex statistical rules. Instead, it utilizes our trained deep learning model to evaluate the DNA sequences surrounding the donor and acceptor sites. splam learns the splice junction patterns. It identifies and removes splice alignments that exhibit low confidence splice junctions.

splam offers solutions to several problems, addressing the following:

1. Distinguishing high-quality spliced alignments from those with low confidence.
2. Providing a systematic approach to assess all splice alignments within an alignment file. Additionally, it eliminates erroneous splice alignments, thereby enhancing downstream transcriptome assembly.
3. Potentially aiding in understanding the biases inherent in splice aligners.
4. There are more potential usage to be explored!

|

Workflow overview
+++++++++++++++++++++++++++++++++++

Before diving into details of each step, this is the overview workflow. :ref:`Figure a <alignment_cleanup_workflow>` is the workflow of running splam in the standard RNA-Seq pipeline, and :ref:`Figure b <alignment_cleanup_workflow>` is the workflow of spurious splice alignment removal.

splam **takes a sorted alignment file**, extracts all splice junctions, and scores all of them. Furthermore, splam cleans up the alignment file by removing spliced alignments with poor quality splice junctions, and **output a new sorted alignment file**. 


.. _alignment_cleanup_workflow:

.. figure::  ../image/alignment_cleanup_workflow.png
    :align:   center
    :scale:   25 %

|

.. _alignment-prepareintput:

Step 1: Preparing your input files
+++++++++++++++++++++++++++++++++++

The first step is to prepare three files for splam analysis:

1. An alignment file in :code:`BAM` format [`example file: SRR1352129_chr9_sub.bam <https://github.com/Kuanhao-Chao/splam/blob/main/test/SRR1352129_chr9_sub.bam>`_].  
2. A reference genome in :code:`FASTA` format [`example file: chr9_subset.fa <https://github.com/Kuanhao-Chao/splam/blob/main/test/chr9_subset.fa>`_].
3. The splam model, which you can find it here: `splam.pt <https://github.com/Kuanhao-Chao/splam/blob/main/model/splam_script.pt>`_

|

.. _alignment-extract-introns:

Step 2: Extracting splice junctions in your alignment file
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In this step, you take :ref:`an alignment file (1) <alignment-prepareintput>` and run

.. code-block:: bash

    splam extract -P SRR1352129_chr9_sub.bam

The primary outputs for this step is a BED file containing the coordinates of each junction and some temporary files. If you only want to extract splice junctions from the BAM file without running the subsequent cleaning step, you can use the :code:`-n / --write-junctions-only` argument to skip writing out temporary files.

splam iterates through the :code:`BAM` file, extracts all splice junctions in alignments, and writes their coordinates into a :code:`BED` file. By default, the :code:`BED` is written into :code:`tmp_out/junction.bed`. The :code:`BED` file consists of six columns: :code:`CHROM`, :code:`START`, :code:`END`, :code:`JUNC_NAME`, :code:`INTRON_NUM`, and :code:`STRAND`. Here are a few entries from the :code:`BED` file:

* **Output**

.. code-block:: text
    :linenos:

    chr9    4849549 4860125 JUNC00000007    3       +
    chr9    5923308 5924658 JUNC00000008    6       -
    chr9    5924844 5929044 JUNC00000009    8       -



Note that in this command, we run with the argument :code:`-P / --paired`. This argument should be selected based on the RNA sequencing read type. There are two types of RNA sequencing read types: single-read and paired-end sequencing. For a more detailed explanation, you can refer to this `page <https://www.illumina.com/science/technology/next-generation-sequencing/plan-experiments/paired-end-vs-single-read.html>`_.

By default, splam processes alignments without pairing and bundling them. If your RNA-Seq sample is single-read, there is no need to set this argument. However, if your RNA-Seq sample is from paired-end sequencing, it is highly recommended to run splam with the :code:`-P / --paired` argument. Otherwise, if an alignment is removed, the flag of its mate will not be unpaired. It is worth noting that it takes longer to pair alignments in the BAM file, but it produces more accurate flags. 

In addition, when running in paired mode, the default gap between bundles is 10000bp. If you set the :code:`-g / --bundle-gap` argument to set the minimum gap betwen bundles. 

|

Step 3: Scoring extracted splice junctions
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In this step, the goal is to score all the extracted splice junctions. To accomplish this, you will need three essential files. Firstly, you should have the BED file that was generated in :ref:`Step 2 <alignment-extract-introns>`. Additionally, you will require two additional files: (1) :ref:`the reference genome (2) <alignment-prepareintput>`, which shares coordinates with the junction BED file, and (2) :ref:`the splam model (3) <alignment-prepareintput>`. Once you have these files in place, you can run the following command:

.. code-block:: bash

    splam score -G chr9_subset.fa -m ../model/splam_script.pt -o tmp_out tmp_out/junction.bed


By default, splam automatically detects your environment and runs in :code:`cuda` mode if CUDA is available. However, if your computer is running macOS, splam will check if :code:`mps` mode is available. If neither :code:`cuda` nor :code:`mps` are available, splam will run in :code:`cpu` mode. You can manually specify the mode using the :code:`-d / --device` argument.

Additionally, you can adjust the batch size using the :code:`-b / --batch-size` argument. We recommend setting a small batch size (default is 10) when running splam in :code:`cpu` mode.


After this step, a new :code:`BED` file is produced, featuring eight columns. Two extra columns, namely :code:`DONOR_SCORE` and :code:`ACCEPTOR_SCORE`, are appended to the file. It is worth noting that any unstranded introns are excluded from the output. (p.s. they might be from unstranded transcripts assembled by StringTie).

* **Output**

.. code-block:: text
    :linenos:

    chr9    4849549 4860125 JUNC00000007    3       +       0.7723698       0.5370769
    chr9    5923308 5924658 JUNC00000008    6       -       0.9999831       0.9999958
    chr9    5924844 5929044 JUNC00000009    8       -       0.9999883       0.9999949



|


Step 4: Cleaning up your alignment file
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

After scoring every splice junction in your alignment file, the final step of this analysis is to remove alignments with low-quality splice junctions and update 'NH' tag and flags for multi-mapped reads. You can pass the directory path to splam using the clean mode, which will output a new cleaned and sorted BAM file. The implementation of this step utilizes the core functions of :code:`samtools sort` and :code:`samtools merge`. If you want to run this step with multiple threads, you can set the :code:`-@ / --threads` argument accordingly.


.. code-block:: bash

    splam clean -o tmp_out -@ 5

|

Step 5: IGV visualization
+++++++++++++++++++++++++++++++++++

Here is an example of the EHMT1 gene locus on chromosome 9 visulaized in IGV. This protein-coding gene is located on the forward strand; however, we have observed that the splice aligner generates several splice alignments on the reverse strand. 


In :ref:`Figure<figure_EHMT1>`, the first three tracks display the coverage, splice junction, and alignment information from the original alignment file of the SRR1352129 sample. The fourth, fifth, and sixth tracks show the coverage, splice junction, and alignment data obtained from the cleaned alignment file of the SRR1352129 sample, which was generated using splam. Many of the spliced alignments on the reverse strand of EHMT1 have splice junctions with low splam scores and were consequently removed. The splam removal procedure results in a more refined gene locus and enhances the transcriptome assembly. The final track represents the RefSeq annotations of the EHMT1 gene.


.. _figure_EHMT1:
.. figure::  ../image/figure_S_EHMT1_original.png
    :align:   center
    :scale:   50 %
.. figure::  ../image/figure_S_EHMT1_cleaned.png
    :align:   center
    :scale:   50 %
.. figure::  ../image/figure_S_EHMT1_annotations.png
    :align:   center
    :scale:   50 %

|
|
|
|

.. image:: ../image/jhu-logo-dark.png
   :alt: My Logo
   :class: logo, header-image
   :align: center